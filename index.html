<!DOCTYPE html>
<head>
<meta charset="utf-8">
<title></title>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css"
   integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ=="
   crossorigin=""/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
 <!-- Make sure you put this AFTER Leaflet's CSS -->
 <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"
   integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw=="
   crossorigin=""></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
<script src="https://stamen-maps.a.ssl.fastly.net/js/tile.stamen.js"></script>
<style type="text/css">
html, body {
  margin: 0 0;
  padding: 0px 0px;
  width: 100%;
  height: 100%;
  font-family: Arial, Helvetica, sans-serif;
}

#map {
  height: 85%;
  width: 100%;
}

div#input {
	margin: 10px;
}

div#input div {
	margin-top: 5px;
}

button, input {
	padding: 2px;
}

.caption {
  padding: 6px 8px;
  font-size: 12px;
  background: #ddd;
  opacity: 1;
  box-shadow: 0 0 15px rgba(0,0,0,0.2);
  border-radius: 5px;
}

td {
  border-radius: 3px;
}

td.name-cell, th.name-cell {
	text-align: left;
	padding: 0px 5px 0px 5px;
}

td.num-cell, th.num-cell {
	text-align: right;
	padding-left: 10px;
}
</style>
</head>
<body>
<div id="input">
<div>Upload precinct geojson: <input type="file" accept=".geojson" id="upload-geojson"></input></div>
<div>Number of groupings to generate: <input type="text" id="cluster-count"> <input type="submit" id="submit-clusters" value="Generate groups"></div>
<div>If you are not satisfied with the initial groups, clicking "generate groups" again will repartition the precincts.</div> 
<div><a href='#' id='export'><button type="button">Export Work</button></a></div>
</div>
<div id="map"></div>
<script>
/* TO DO:
x Clustering by door count
x Add congressional district boundaries; show/hide
x Add door density to tooltip
x Fix file export
x Add "null" office option (color + in caption)
*/

// initialize map
var map = new L.Map("map", {
    center: [41.88,-87.63],
    zoom: 8,
    doubleClickZoom: false,
    preferCanvas: true,
});

map.addLayer(new L.StamenTileLayer("toner-lite"));

var geojsonGroup = L.layerGroup(),
		cdGroup = L.layerGroup(),
		drawnItems = L.featureGroup();

geojsonGroup.addTo(map);
cdGroup.addTo(map);
drawnItems.addTo(map);

L.control.layers({
  'drawlayer': drawnItems
}).addTo(map);

var drawControl = new L.Control.Draw({
  draw: {
    polygon: false,
    circle: false,
    circlemarker: false,
    marker: true,
    polyline: false,
    rectangle: false,
  },  
  edit: {
    featureGroup: drawnItems,
    poly: {
      allowIntersection: false
    }
  }
}).addTo(map);

map.on(L.Draw.Event.CREATED, function (e) {
  var type = e.layerType,
      layer = e.layer;

  drawnItems.addLayer(layer); 
});

var caption = L.control({
  maxHeight: 100,
});

caption.onAdd = function (map) {
  this._div = L.DomUtil.create("div", "caption");
  this.update();
  return this._div;
};

caption.update = function (d) {
  this._div.innerHTML = (!d ? "Choose # of clusters" : buildTable(rollupPrecincts(d)));
};

caption.addTo(map);

var color = d3.scaleOrdinal()
		.range(d3.schemeSet3)
		.unknown("#76797E");

function formatNumber(num) {
  return num.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1,')
}

function defaultStyle(feature) {
  return {
	  fillColor: 'blue',
	  fillOpacity: 0.5,
	  color: 'black',
	  opacity: 1,
	  weight: 1,
	  className: "precincts"
 	};
}

function clusterStyle(feature) {
  return {
	  fillColor: color(feature.properties.cluster),
	  fillOpacity: 0.5,
	  color: 'black',
	  opacity: 1,
	  weight: 1,
	  className: "precincts"
 	};
}

function cdStyle(feature) {
	return {
		color: 'black',
		weight: 3,
		fillOpacity: 0,
	}
}

function toolTip(p) {
	return "<table><tr><th colspan='2'>" + p.pct_name + "</th></tr><tr><td>Doors</td><td>" + p.doors + "</td></tr><tr><td>Targets</td><td>" + p.targets + "</td></tr><tr><td>Door density</td><td>" + Math.round(p.door_density) / 100 + "</td></tr></table>";
}

function rollupPrecincts(precincts) {
	return d3.nest()
  	.key(d => d.properties.cluster)
  	.rollup(v => {
  		return {
	  		doors: d3.sum(v, d => d.properties.doors),
	  		targets: d3.sum(v, d => d.properties.targets)
	  	};
	  })
  	.entries(precincts.features);
}

function buildTable(obj) {
	var tableHead = "<table><thead><tr><th class='name-cell'>District</th><th class='num-cell'>Doors</th><th class='num-cell'>Targets</th></tr></thead>",
			content = obj.sort((a,b) => a.key - b.key).map(d => "<tr><td class='name-cell' style='background-color:" + color(d.key) + "'>" + (d.key >= 0 ? d.key : "N/A") + "</td><td class='num-cell'>" + formatNumber(d.value.doors) + "</td><td class='num-cell'>" + formatNumber(d.value.targets) + "</td></tr>").join('');
	return tableHead + content + "</table>"
}

d3.select("#upload-geojson")
		.on("change", function() {
			var file = d3.event.target.files[0];
			if (file) {
				geojsonGroup.clearLayers();
				var reader = new FileReader();
				reader.onloadend = function(e) {
					var dataURL = e.target.result;
					loadGeojson(dataURL);
				};
				reader.readAsDataURL(file);
			}
		})

function generateClusters(precincts, numberOfClusters) {
	if (!+numberOfClusters) {
		console.log("Must chose an integer > 0")
		return;
	}
	
	geojsonGroup.clearLayers();
	/* Unweighted clustering by precinct centroid location
	var centroids = turf.featureCollection((precincts.features.map(d => turf.centroid(d, d.properties)))),
			clusters = turf.clustersKmeans(centroids, {numberOfClusters: numberOfClusters});
	*/

	// weighted clustering takes into account number of doors in precinct
	var x = precincts.features.map(d => turf.centroid(d, d.properties)),
			y = d3.shuffle(x.map(d => Array(d.properties.doors).fill(d)).flat()),
			centroids = turf.featureCollection(y),
			clusters = turf.clustersKmeans(centroids, {numberOfClusters: numberOfClusters});

	precincts.features.forEach(f => {
		var match = clusters.features.find(f2 => f2.properties.objectid_1 === f.properties.objectid_1)
		f.properties.cluster = match.properties.cluster
	});

	var extent = d3.extent(precincts.features, d => d.properties.cluster),
  		range = d3.range(extent[0], extent[1] + 1);
  color.domain(range);

  function onEachFeature(feature, layer) {
		feature.properties.cluster = +feature.properties.cluster;

		var select = document.createElement("select");

		select.classList.add("district-select");

		d3.select(select).selectAll("option")
			  .data(d3.range(extent[0] - 1, extent[1] + 1))
			.enter().append("option")
			  .attr("class", "district-option")
			  .attr("value", d => d)
			  .style("background-color", d => color(d))
			  .text(d => (d >= 0 ? d : "N/A"));

		d3.select(select).property("value", -2);

		d3.select(select).on("change", function(d) {
			feature.properties.cluster = this.value;
			layer.setStyle({'fillColor': color(this.value)});
	  	caption.update(precincts)
	  	map.closePopup();
	  });

		layer.bindPopup(select)
	}

  geojson = L.geoJson(precincts, {
    style: clusterStyle,
    onEachFeature: onEachFeature,
  });
  geojson.bindTooltip(layer => toolTip(layer.feature.properties), {direction: 'bottom', sticky: true});

  geojson.addTo(geojsonGroup);
  caption.update(precincts);
}

function loadGeojson(geojsonURL) {
	caption.update(null);
	
	d3.json("us_cd116.geojson").then((cds) => {
		us = L.geoJson(cds, {
			style: cdStyle,
		})
		us.addTo(cdGroup);
	});

	d3.json(geojsonURL).then((precincts) => {
		d3.select("#submit-clusters")
		.on("click", function() {
			generateClusters(precincts, document.getElementById("cluster-count").value);
		})	

		geojson = L.geoJson(precincts, {
			style: defaultStyle,
	  });
	  geojson.bindTooltip(layer => toolTip(layer.feature.properties), {direction: 'bottom', sticky: true});

	  geojson.addTo(geojsonGroup);

	  var bbox = geojson.getBounds();
    map.flyToBounds(bbox);
	});
}

d3.select("#export")
		.on("click", function() {
		  // Extract GeoJson from featureGroup
		  var data = geojsonGroup.toGeoJSON();

		  // Stringify the GeoJson
		  var convertedData = 'text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(data));
		  // Create export
		  document.getElementById('export').setAttribute('href', 'data:' + convertedData);
		  document.getElementById('export').setAttribute('download','data.geojson');
		});
</script>
</body>
</html>